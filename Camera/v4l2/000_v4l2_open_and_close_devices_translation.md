## 第一章. 通用API

对一个V4L2的设备进行编程主要包含以下步骤:
* 开启设备.
* 更改设备的属性, 选择视频和音频的输入, 视频制式, 图像亮度等等.
* 协商数据格式
* 协商输入输出的方式
* 开始实际的输入/输出循环
* 关闭设备

在实际的应用过程中有一个步骤是可选或是没有必要执行的.这依赖于V4L2设备的类型,详细的情况你可以查看**第四章, 编程接口**. 在本章, 我们将讨论对于所有设备都有效的基本概念.

### 打开和关闭设备

#### 设备名称
V4L2驱动作为一个内核模块被实现, 由系统管理员手动或是在设备首次被发现时加载. V4L2驱动模块以模块的方式被集成到"Videodev"内核模块.在本文档中将提供辅助函数和一个共同的应用程序编程接口.

每一个驱动都以主节点号为81和次节点号为0到255的方式被注册为一个或是多个设备节点.次节点号是被动态分配的,除非在编译kernel是指定了`CONFIG_VIDEO_FIXED_MINOR_RANGES`选项. 在这种状态下, 次节点号的数字范围依赖于设备节点的类型(例如视频,无线广播设备等)

很多驱动支持 "video_nr", "radio_nr" 或是 "vbi_nr" 模式选项来驱分 视频/广播/VBI 节点数字. 这将允许用户请求设备节点的名字如"dev/video5" 代替原来的方式.当驱动程序支持多种相同类型的设备,分配设备节点的命名由逗号分隔:
>modprobe mydriver video_nr=0,1 radio_nr=0,1

在 `/etc/modules.conf` 文件中可能会写为:
>options mydriver video_nr=0,1 radio_nr=0,1

当没有设备节点号作为一个模块选项被指定,驱动程序应该提供一个默认设备节点号.

正常情况下udev将自动为你在`/dev`下创建设备节点. 如果udev没有安装, 你就需要主动开启`CONFIG_VIDEO_FIXED_MINOR_RANGES` 编译内核选项来正确的使设备节点与次节点号关联. 例如你需要明确的指出次节点名 "5" 关联到节点名称 "video5". 使用该内核选项使得不同类型的设备拥用不同范围的次节点号. 这些不同范围的次节点号在**第四章. 接口**中被详细列出.

通过`mknod`创建的字符文件是享有特权操作的,不能通过设备主节点号和次节点号来打开.这就意味着应用程序不能依赖可靠的扫描来加载或是安装驱动. 用户必须输入设备名称, 或是应用程序尝试转换设备名称.

#### 相关设备

设备可以支持很多不同的功能. 例如录像, VBI拍照以及广播接收等.

V4L2编程接口为这些功能创建不同的节点.

V4L2编程接口设计的目标是一个设备节点可以支持所有的功能. 然尔, 实际的情况不是这个样子的:这个特性从来没有被应用程序使用并且很多驱动也没有支持,即使支持也没有测试. 另外, 在不同功能之间转换设备
节点也只是在使用 "streaming I/O" API 的时候有效, 在 "read()/write()" API 是没有效果的.

现在, 每一个设备节点仅支持一个功能.

除了视频输入或是输出, 硬件也可以支持视频的采样或是回放. 如果是这样,这些功能作为ALSA PCM设备可选的ALSA混音器设备被实现.

这些设备存在的一个问题是 V4L2 的API没有规定去查找这些相关设备. 因此一些很复杂的设备使用 `Media Controller`(详见'第18章, 媒体控制器') 来实现这个目的.
但是大部分驱动没有使用它, 因为存在一代码使用`sysfs`去发现相关装置(详情查看 `v4l-utils` 的 Git 仓库中的`libmedia_dev`),  目前还没有`library`提供对两个媒体控制设备控制的单一API而不使用`Media Controller`. 如果你想从事这方面的工作请向 `linux-media` 发送邮件:[http://www.linuxtv.org/lists.php](http://www.linuxtv.org/lists.php)

#### 多次打开设备
V4L2 设备可以被打开多次. 当这个功能被驱动所支持, 用户就可以在应用程序录像或是录音的过程启动一个用户程序控制面板来控制图像亮度或是音频声音大小.
也就是说,面板应用比得上一个ALSA音频混合器应用. 仅仅打开一个V4L2设备不应用改变设备当前的状态.

一旦应用程序为流数据申请了内存缓冲区(通过调用`VIDIOC_REQBUFS` 或是 `VIDIOC_CREATE_BUFS` ioctl控制, 或是隐式的调用 `read()` 或是 `write()` 函数), 应用程序就会成功该设备的所有者. 设备将不再允许改变缓冲区大小的操作(例如调用 VIDICO_S_FMT ioctl) 并且其他应用程序不再允许申请缓冲区,打开或是停止数据流. 如果强制调用,会返回一个 `EBUSY` 的错误代码.

仅仅打开一个V4L2的设备不授予独占访问的授权.无论对请求类型数据分配的权限是读还是写，初始化数据都会发生交换，而且还会改变文件句柄的相关属性。应用程序可以通过使用优先级机制附加请求访问,具体描述可以看**应用程序优先级**章节

#### 共享流数据

V4L2驱动不应当支持多个应用程序在同一个设备上通过复制缓冲区,时间多路复用或是其他方式读写同一个数据流. 通过在用户空间使用代理应用程序来处理这种情况会更好.

#### 函数
分来使用`open()`和`close()`函数来打开和关闭设备. 使用`icotl()`函数来能设备进行编程, 这将会在下面的章节中描述.
